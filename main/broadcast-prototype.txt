#include <stdio.h>
#include <string.h>

#include "freertos/FreeRTOS.h"
#include "freertos/queue.h"
#include "freertos/task.h"

#include "esp_event.h"
#include "esp_log.h"
#include "esp_now.h"
#include "esp_system.h"
#include "esp_wifi.h"

#include "driver/gpio.h"
#include "nvs_flash.h"

/* ===================== CONFIG ===================== */

#define TAG "ESP_NOW_BROADCAST"

#define LED_GPIO GPIO_NUM_2
#define BUTTON_GPIO GPIO_NUM_0

#define ESPNOW_CHANNEL 6
#define MSG_TTL 5
#define CACHE_SIZE 32

static const uint8_t ESPNOW_BROADCAST_MAC[6] = {0xFF, 0xFF, 0xFF,
                                                0xFF, 0xFF, 0xFF};

/* ===================== MESSAGE ===================== */

typedef struct {
  uint8_t src_mac[6];
  uint8_t dst_mac[6];
  int8_t rssi;
  uint8_t origin_mac[6];
  uint32_t msg_id;
  uint8_t ttl;
} __attribute__((packed)) espnow_msg_t;

/* ===================== GLOBALS ===================== */

static QueueHandle_t rx_queue;
static QueueHandle_t tx_queue;

static uint32_t local_msg_counter = 0;

/* ===================== DEDUP CACHE ===================== */

typedef struct {
  uint8_t mac[6];
  uint32_t msg_id;
} msg_cache_t;

static msg_cache_t msg_cache[CACHE_SIZE];
static uint8_t cache_index = 0;

static bool msg_seen(const espnow_msg_t *msg) {
  for (int i = 0; i < CACHE_SIZE; i++) {
    if (!memcmp(msg_cache[i].mac, msg->origin_mac, 6) &&
        msg_cache[i].msg_id == msg->msg_id) {
      return true;
    }
  }

  memcpy(msg_cache[cache_index].mac, msg->origin_mac, 6);
  msg_cache[cache_index].msg_id = msg->msg_id;
  cache_index = (cache_index + 1) % CACHE_SIZE;

  return false;
}

/* ===================== LED ===================== */

static void blink_led(void) {
  for (int i = 0; i < 3; i++) {
    gpio_set_level(LED_GPIO, 1);
    vTaskDelay(pdMS_TO_TICKS(100));
    gpio_set_level(LED_GPIO, 0);
    vTaskDelay(pdMS_TO_TICKS(100));
  }
}

/* ===================== ESPNOW RX CALLBACK ===================== */

static void espnow_recv_cb(const esp_now_recv_info_t *info, const uint8_t *data,
                           int len) {
  if (len != sizeof(espnow_msg_t))
    return;

  espnow_msg_t msg;
  memcpy(&msg, data, sizeof(msg));

  memcpy(msg.src_mac, info->src_addr, 6);
  memcpy(msg.dst_mac, info->des_addr, 6);
  msg.rssi = info->rx_ctrl->rssi;

  xQueueSendFromISR(rx_queue, &msg, NULL);
}

/* ===================== RX TASK ===================== */

static void espnow_rx_task(void *arg) {
  espnow_msg_t msg;

  while (1) {
    if (xQueueReceive(rx_queue, &msg, portMAX_DELAY)) {

      if (msg_seen(&msg)) {
        ESP_LOGI(TAG,
                 "IN msg_id=%lu "
                 "src=%02X:%02X:%02X:%02X:%02X:%02X "
                 "dst=%02X:%02X:%02X:%02X:%02X:%02X "
                 "origin=%02X:%02X:%02X:%02X:%02X:%02X ",
                 msg.msg_id, msg.src_mac[0], msg.src_mac[1], msg.src_mac[2],
                 msg.src_mac[3], msg.src_mac[4], msg.src_mac[5], msg.dst_mac[0],
                 msg.dst_mac[1], msg.dst_mac[2], msg.dst_mac[3], msg.dst_mac[4],
                 msg.dst_mac[5], msg.origin_mac[0], msg.origin_mac[1],
                 msg.origin_mac[2], msg.origin_mac[3], msg.origin_mac[4],
                 msg.origin_mac[5]);
        continue;
      }

      ESP_LOGI(TAG,
               "RX msg_id=%lu "
               "src=%02X:%02X:%02X:%02X:%02X:%02X "
               "dst=%02X:%02X:%02X:%02X:%02X:%02X "
               "origin=%02X:%02X:%02X:%02X:%02X:%02X "
               "ttl=%u rssi=%d",
               msg.msg_id, msg.src_mac[0], msg.src_mac[1], msg.src_mac[2],
               msg.src_mac[3], msg.src_mac[4], msg.src_mac[5], msg.dst_mac[0],
               msg.dst_mac[1], msg.dst_mac[2], msg.dst_mac[3], msg.dst_mac[4],
               msg.dst_mac[5], msg.origin_mac[0], msg.origin_mac[1],
               msg.origin_mac[2], msg.origin_mac[3], msg.origin_mac[4],
               msg.origin_mac[5], msg.ttl, msg.rssi);

      blink_led();

      if (msg.ttl > 0) {
        msg.ttl--;
        xQueueSend(tx_queue, &msg, portMAX_DELAY);
      }
    }
  }
}

/* ===================== TX TASK ===================== */

static void espnow_tx_task(void *arg) {
  espnow_msg_t msg;

  while (1) {
    if (xQueueReceive(tx_queue, &msg, portMAX_DELAY)) {
      esp_err_t err =
          esp_now_send(ESPNOW_BROADCAST_MAC, (uint8_t *)&msg, sizeof(msg));

      if (err != ESP_OK) {
        ESP_LOGE(TAG, "esp_now_send failed: %s", esp_err_to_name(err));
      }
    }
  }
}

/* ===================== BUTTON TASK ===================== */

static void button_task(void *arg) {
  uint8_t mac[6];
  esp_wifi_get_mac(WIFI_IF_STA, mac);

  int last = 1;

  while (1) {
    int current = gpio_get_level(BUTTON_GPIO);

    if (last == 1 && current == 0) {

      espnow_msg_t msg = {0};
      memcpy(msg.origin_mac, mac, 6);
      msg.msg_id = local_msg_counter++;
      msg.ttl = MSG_TTL;

      xQueueSend(tx_queue, &msg, portMAX_DELAY);
      ESP_LOGI(TAG,
               "TX msg_id=%lu "
               "src=%02X:%02X:%02X:%02X:%02X:%02X "
               "dst=FF:FF:FF:FF:FF:FF "
               "origin=%02X:%02X:%02X:%02X:%02X:%02X "
               "ttl=%u",
               msg.msg_id, mac[0], mac[1], mac[2], mac[3], mac[4], mac[5],
               msg.origin_mac[0], msg.origin_mac[1], msg.origin_mac[2],
               msg.origin_mac[3], msg.origin_mac[4], msg.origin_mac[5],
               msg.ttl);
    }

    last = current;
    vTaskDelay(pdMS_TO_TICKS(50));
  }
}

/* ===================== WIFI INIT ===================== */

static void wifi_init(void) {
  ESP_ERROR_CHECK(esp_netif_init());
  ESP_ERROR_CHECK(esp_event_loop_create_default());

  wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
  ESP_ERROR_CHECK(esp_wifi_init(&cfg));

  ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_APSTA));
  ESP_ERROR_CHECK(esp_wifi_start());

  ESP_ERROR_CHECK(esp_wifi_set_channel(ESPNOW_CHANNEL, WIFI_SECOND_CHAN_NONE));

  ESP_ERROR_CHECK(esp_wifi_set_ps(WIFI_PS_NONE));
}

/* ===================== ESPNOW INIT ===================== */

static void espnow_init(void) {
  ESP_ERROR_CHECK(esp_now_init());
  ESP_ERROR_CHECK(esp_now_register_recv_cb(espnow_recv_cb));

  esp_now_peer_info_t peer = {0};
  memcpy(peer.peer_addr, ESPNOW_BROADCAST_MAC, 6);
  peer.channel = 0; // use current Wi-Fi channel
  peer.ifidx = WIFI_IF_STA;
  peer.encrypt = false;

  ESP_ERROR_CHECK(esp_now_add_peer(&peer));
}

/* ===================== GPIO INIT ===================== */

static void gpio_init_all(void) {
  gpio_config_t led_cfg = {
      .pin_bit_mask = 1ULL << LED_GPIO,
      .mode = GPIO_MODE_OUTPUT,
  };
  gpio_config(&led_cfg);

  gpio_config_t btn_cfg = {
      .pin_bit_mask = 1ULL << BUTTON_GPIO,
      .mode = GPIO_MODE_INPUT,
      .pull_up_en = GPIO_PULLUP_ENABLE,
  };
  gpio_config(&btn_cfg);
}

/* ===================== MAIN ===================== */

void app_main(void) {
  ESP_ERROR_CHECK(nvs_flash_init());

  rx_queue = xQueueCreate(10, sizeof(espnow_msg_t));
  tx_queue = xQueueCreate(10, sizeof(espnow_msg_t));

  gpio_init_all();
  wifi_init();
  espnow_init();

  xTaskCreate(espnow_rx_task, "espnow_rx", 4096, NULL, 5, NULL);
  xTaskCreate(espnow_tx_task, "espnow_tx", 4096, NULL, 5, NULL);
  xTaskCreate(button_task, "button", 2048, NULL, 4, NULL);

  ESP_LOGI(TAG, "ESP-NOW broadcast mesh ready");
}
